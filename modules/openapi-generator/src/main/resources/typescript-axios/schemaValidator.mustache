import * as fs from 'fs';
import * as path from 'path';
import { isNullOrUndefined } from 'util';

type ValidationError = {
    message: string;
    path: string;
};

type ValidationResult = {
    isValid: boolean;
    errors: ValidationError[];
};

type XmlObject = {
    name?: string;
    namespace?: string;
    prefix?: string;
    attribute?: boolean;
    wrapped?: boolean;
};

type ExternalDocsObject = {
    description?: string;
    url?: string;
};

type DiscriminatorObject = {
    propertyName: string;
    mapping?: { [key: string]: string };
};

type OpenApiSchema = {
    type?: string;
    title?: string;
    description?: string;
    default?: any;
    format?: string;
    multipleOf?: number;
    maximum?: number;
    exclusiveMaximum?: boolean;
    minimum?: number;
    exclusiveMinimum?: boolean;
    maxLength?: number;
    minLength?: number;
    pattern?: string;
    maxItems?: number;
    minItems?: number;
    uniqueItems?: boolean;
    maxProperties?: number;
    minProperties?: number;
    required?: string[];
    enum?: any[];
    items?: OpenApiSchema | OpenApiSchema[];
    allOf?: OpenApiSchema[];
    properties?: { [key: string]: OpenApiSchema };
    additionalProperties?: OpenApiSchema | boolean;
    readOnly?: boolean;
    xml?: XmlObject;
    externalDocs?: ExternalDocsObject;
    example?: any;
    discriminator?: DiscriminatorObject;
    anyOf?: OpenApiSchema[];
    oneOf?: OpenApiSchema[];
    not?: OpenApiSchema;
    itemsList?: OpenApiSchema[];
    $ref?: string;
    nullable?: boolean;
    additionalItems?: OpenApiSchema | boolean;
    style?: string;
    explode?: boolean;
    in?: string;
    writeOnly?: boolean;
    deprecated?: boolean;
};

type OpenApiSwagger = {
    definitions: { [key: string]: OpenApiSchema };
};

export class SwaggerValidator {
    private swagger: OpenApiSwagger;

    constructor(swaggerPath: string) {
        this.swagger = this.loadSwagger(swaggerPath);
    }

    public getSwagger(){
        return this.swagger;
    }

    private loadSwagger(filePath: string): OpenApiSwagger {
        const content = fs.readFileSync(filePath, 'utf-8');
        return JSON.parse(content);
    }

    private resolveRef(refOrSchema: string | OpenApiSchema): OpenApiSchema {
        if (typeof refOrSchema === 'object' && refOrSchema.$ref !== undefined) {
            refOrSchema = refOrSchema.$ref;
        }

        if (typeof refOrSchema === 'string' && refOrSchema.startsWith('#/definitions/')) {
            const definitionName = refOrSchema.substring('#/definitions/'.length);
            return this.swagger.definitions[definitionName];
        } else {
            return refOrSchema as OpenApiSchema;
        }
    }

    private validateProperty(schema: OpenApiSchema, value: any, path: string): ValidationError[] {
        const errors: ValidationError[] = [];

        // Validate nullable required field
        if (schema.required && schema.required.includes(path) && value === null) {
            return errors; // Nullable required field is considered valid
        }

        if (!isNullOrUndefined(value) && schema.type && schema.type === 'array' && !Array.isArray(value)) {
            errors.push({
                message: `Implementation returns wrong data type. Type mismatch for property path: ${path}, expected type: array found ${typeof value}`,
                path,
            });
        }else if (!isNullOrUndefined(value) && schema.type && typeof value !== schema.type && schema.type !== 'integer' && schema.type !== 'array' ) {
            errors.push({
                message: `Implementation returns wrong data type. Type mismatch for property path: ${path}, expected type: ${schema.type} found ${typeof value}`,
                path,
            });
        }

        // Validate additional constraints for integer
        if (schema.type === 'integer' && typeof value !== 'number') {

            errors.push({
                message: `Implementation returns wrong data type. Type mismatch for property path: ${path}, expected type: ${schema.type} found ${typeof value}`,
                path,
            });
            
        }

        // Validate format
        if (schema.format && schema.format === 'date-time') {
            const dateTimeRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{2,7})?Z$/;
            if (!dateTimeRegex.test(value)) {
                errors.push({
                    message: `Invalid date-time format for property path : ${path} found value as ${value}`,
                    path,
                });
            }
        }

        // Validate pattern
        if (schema.pattern && typeof value === 'string' && !new RegExp(schema.pattern).test(value)) {
            errors.push({
                message: `Pattern mismatch for property path : ${path}, expected pattern: ${schema.pattern}, found ${value}`,
                path,
            });
        }

        // Validate minLength
        if (schema.minLength && typeof value === 'string' && value.length < schema.minLength) {
            errors.push({
                message: `String length is less than minLength for property path: ${path}, minLength: ${schema.minLength} found value ${value}`,
                path,
            });
        }

        // Validate maxLength
        if (schema.maxLength && typeof value === 'string' && value.length > schema.maxLength) {
            errors.push({
                message: `String length is more than maxLength for property path: ${path}, minLength: ${schema.minLength} found value ${value}`,
                path,
            });
        }

        // Validate anyOf
        if (schema.anyOf && !schema.anyOf.some(subschema => this.validate(this.resolveRef(subschema), value, path).length === 0)) {
            errors.push({
                message: `Value does not match anyOf`,
                path,
            });
        }

        // Validate oneOf
        if (schema.oneOf && schema.oneOf.filter(subschema => this.validate(this.resolveRef(subschema), value, path).length === 0).length !== 1) {
            errors.push({
                message: `Value does not match exactly oneOf`,
                path,
            });
        }

        // Validate not
        if (schema.not && this.validate(this.resolveRef(schema.not), value, path).length === 0) {
            errors.push({
                message: `Value matches not schema`,
                path,
            });
        }

        // Validate style and explode for arrays in query parameters
        if (schema.in === 'query' && schema.type === 'array' && schema.style && schema.explode !== undefined) {
            const arrayValue = Array.isArray(value) ? value : [value];
            if (schema.style === 'form' && schema.explode) {
                const itemsSchema = Array.isArray(schema.items) ? schema.items[0] : schema.items; // Access the first item
                arrayValue.forEach((item, index) => {
                    const resolvedItemSchema = itemsSchema?.$ref ? this.resolveRef(itemsSchema.$ref) : itemsSchema;
                    if (resolvedItemSchema !== undefined) {
                        errors.push(...this.validate(resolvedItemSchema, item, `${path}[${index}]`));
                    }
                });
            } else {
                errors.push({
                    message: `Unsupported style and explode combination for array in query parameter`,
                    path,
                });
            }
        }

        return errors;
    }

    private validateObject(schema: OpenApiSchema, data: any, path: string): ValidationError[] {
        const { properties, required, additionalProperties, readOnly } = schema;
        const errors: ValidationError[] = [];

        // Check for readonly properties
        if (readOnly && data !== undefined) {
            errors.push({
                message: `Readonly property found with value: ${data}`,
                path,
            });
        }

        // Validate each property
        for (const propertyName in data) {
            const propertySchema = this.resolveRef(properties![propertyName]);
            const propertyValue = data[propertyName];

            // Check if required property is missing
            if (required && required.includes(propertyName) && propertyValue === undefined) {
                errors.push({
                    message: `Required property missing: ${propertyName}`,
                    path,
                });
            }

            // Check if property is defined in the schema
            if (!propertySchema) {
                errors.push({
                    message: `Spec is out of sync with implementation. Property "${propertyName}" is not defined in the schema`,
                    path,
                });
            } else {
                // Validate property recursively
                if (propertyValue !== undefined) {
                    errors.push(...this.validate(propertySchema, propertyValue, `${path}.${propertyName}`));
                }
            }
        }

        // Validate additional properties
        if (additionalProperties && typeof additionalProperties === 'object' && properties) {
            for (const propertyName in data) {
                if (!properties[propertyName]) {
                    const additionalItemSchema = additionalProperties.$ref ? this.resolveRef(additionalProperties.$ref) : additionalProperties;
                    errors.push(...this.validate(additionalItemSchema, data[propertyName], `${path}.${propertyName}`));
                }
            }
        }

        return errors;
    }

    private validateArray(schema: OpenApiSchema, data: any[], path: string): ValidationError[] {
        const errors: ValidationError[] = [];

        // Validate additionalItems
        if (schema.additionalItems !== undefined && schema.type === 'array') {
            if (typeof schema.additionalItems === 'boolean') {
                if (!schema.additionalItems && data.length > schema.itemsList!.length) {
                    errors.push({
                        message: `Additional items not allowed in array`,
                        path,
                    });
                }
            } else {
                const additionalItemSchema = Array.isArray(schema.additionalItems) ? schema.additionalItems[0] : schema.additionalItems;
                for (let i = schema.itemsList!.length; i < data.length; i++) {
                    const resolvedItemSchema = additionalItemSchema.$ref ? this.resolveRef(additionalItemSchema.$ref) : additionalItemSchema;
                    errors.push(...this.validate(resolvedItemSchema, data[i], `${path}[${i}]`));
                }
            }
        }

        // Validate style and explode for arrays in query parameters
        if (schema.in === 'query' && schema.type === 'array' && schema.style && schema.explode !== undefined) {
            const arrayValue = Array.isArray(data) ? data : [data];
            if (schema.style === 'form' && schema.explode) {
                const itemsSchema = Array.isArray(schema.items) ? schema.items[0] : schema.items; // Access the first item

                arrayValue.forEach((item, index) => {
                    const resolvedItemSchema = itemsSchema?.$ref ? this.resolveRef(itemsSchema.$ref) : itemsSchema;
                    if (resolvedItemSchema !== undefined) {
                        errors.push(...this.validate(resolvedItemSchema, item, `${path}[${index}]`));
                    }
                });
            } else {
                errors.push({
                    message: `Unsupported style and explode combination for array in query parameter`,
                    path,
                });
            }
        }

        return errors;
    }

    private validate(schema: OpenApiSchema, data: any, path: string = ''): ValidationError[] {
        const resolvedSchema = this.resolveRef(schema);
        const errors: ValidationError[] = [];

        // Validate type-specific constraints
        errors.push(...this.validateProperty(resolvedSchema, data, path));

        if (resolvedSchema.type === 'object') {
            errors.push(...this.validateObject(resolvedSchema, data, path));
        } else if (resolvedSchema.type === 'array') {
            errors.push(...this.validateArray(resolvedSchema, data, path));
        }

        return errors;
    }

    public validateAgainstDefinition(definitionName: string, data: any): ValidationResult {
        const definitionSchema = this.resolveRef(`#/definitions/${definitionName}`);
        let validationErrors: ValidationError[] = [];
        if (!isNullOrUndefined(definitionSchema)) {
            validationErrors = this.validate(definitionSchema, data);
        }

        return {
            isValid: validationErrors.length === 0,
            errors: validationErrors,
        };
    }
}